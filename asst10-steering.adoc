include::header.adoc[]

:title: Assignment 10: Steering and crowds
:Author Initials: ASN
:Date:    2020-02-07
:Revision: 0.1
:Dir: assignments/a7-motion
:stem: latexmath

= {title}

_In which, we implement a steering algorithm and crowd behaviors_

**Due Friday, Dec 3, before midnight**
     
The goal of this lab is to 

* Implement a physics-based steering model for our character 
* Implement a variety of boid behaviors

<!--<br>
<center>
<video controls>
		<source src="steering.ogv">
</video>
</center>
<br>
-->

= Get the source

On Github, do a `Fetch Upstream` to synchronize your forked repository with the class repository.

Then update the source on your local machine and rebuild.

[source]
----
> git pull
> cd build
> cmake ..; make
----

:sectnums:

= Steerable character

<h2>User interface overview</h2>
<hr>

<p>The camera can be controlled with the mouse:

<ul>
    <li>Left-button drag with the mouse to rotate
    <li>Right-button drag with the mouse to pan
    <li>Middle-button drag with the mouse to zoom
    <li>'f' button will focus the view on the character
</ul>

<p>Control-left click will set the position of the target (red dot)

<p>Pressing the spacebar will reset the character at (0,0,0)

<p>The code for this assignment includes the class ASteerable, which implements a 
steerable character, and the class ABehavior, which implements various steering behaviors.
Subclasses of ABehavior compute desired velocities which are 'fed' to the steering 
algorithm in ASteerable. You can control how a character moves by changing its behavior.

<p>We will build up our steering model in steps. 

<h3>Step 1: Implement a simple seek behavior with basic steering model</h3>

<p><b>(5 points)</b> Implement ASeek::computeDesiredVelocity(const ASteerable&amp; actor). 
Also, set a default value for the constant ASeek::kMaxSpeed. 
You may need to tweak this parameter to produce nice looking 
results with your steering algorithm.

<p><b>(5 points)</b> Compute _vd and _thetad in ASteerable::senseControlAct(const AVector3&amp; veld, double dt). Given a desired velocity and dt, senseControlAct() computes a global translation and rotation 
and stores them in the member variable ATransform _characterRoot. To test your computation of _vd and _thetad, set the 
_characterRoot using the following approach, e.g. 
<ol>
<li>Compute \( \theta_d \). Store the result in member variable _thetad
<li>Compute \( v_d \). Store the result in member variable _vd
<li>Compute a new orientation \( R_y \) using \( \theta_d \) 
<li>Compute a new velocity in global coordinates using v<sub>d</sub>, e.g. 
\( v^{t} = R_y \left( \begin{array}{c} 
0 \\
0 \\
v_d
\end{array} \right)
\)
<li>Compute a new position using v<sup>t</sup>, 
e.g. \( p^{t+\Delta t} = p^t + v^t \Delta t \)
<li>Update _characterRoot with the new position and orientation
</ol>

<p>Note above that although in class, the vehicle has X forward (and rotates around Z), 
note that in your basecode <b>Z is forward (and we rotate around Y)</b>.

<p>Your application should look like this

<br>
<br>
<img src="simpleSteer.gif">
<br>
<br>

<h3>Step 2: Implement translational dynamics (linear forces)</h3>

<p><b>(5 points)</b> Extend ASteerable::senseControlAct(const AVector3&amp; veld, double dt)
to implement linear dynamics. Compute a force based on _vd and the current velocity (stored 
in _state[VEL]). Use this force to compute derivatives and update the state for POS and VEL.
To test, update the translation of _characterRoot based on the computed located position
<ol>
<li>Compute a new orientation \( R_y \) using \( \theta_d \) 
<li>Compute global change in position as
\( \Delta p = R_y \left( \begin{array}{c} 
0 \\
0 \\
x^{t+\Delta t}
\end{array} \right)
\) where x is the local position stored in the character's state vector.
<li>Compute a new position, 
e.g. \( p^{t+\Delta t} = p^t + \Delta p \)
<li>Update _characterRoot with the new position and orientation
</ol>

<!--
<p>You may notice some weird behavior after imlementing this. Maybe something even like 

<br>
<br>
<img src="badForces1.gif">
<br>
<br>

<p><b>(2 points)</b> Remember in class: we talked about accuracy and stability for 
numerical methods. We are currently using Euler's Method to simulate our character's 
movement. Why and how is this happening (in your readme, answer in 1-2 sentences)? 

<p>To fix the problem, adjust the gain, ASteerable::kVelKv, which you use to compute _force. 

Your character should now look something like
-->

<br>
<br>
<img src="forcesOnly.gif">
<br>
<br>

<h3>Step 3: Implement rotational dynamics (torques)</h3>

<p><b>(5 points)</b> Extend ASteerable::senseControlAct(const AVector3&amp; veld, double dt)
to implement rotational dynamics. Compute a torque based on _thetad and the current orientation (stored 
in _state[ORI]). Use this force to compute derivatives and update the state for ORI and AVEL.
To complete your steerable character, update the translation and orientation of _characterRoot based on the current state
<ol>
<li>Compute a new orientation \( R_y \) using \( \theta^{t+\Delta t} \) 
<li>Compute global change in position as
\( \Delta p = R_y \left( \begin{array}{c} 
0 \\
0 \\
x^{t+\Delta t}
\end{array} \right)
\) where x is the local position stored in the character's state vector.
<li>Compute a new position, 
e.g. \( p^{t+\Delta t} = p^t + \Delta p \)
<li>Update _characterRoot with the new position and orientation
</ol>

<p>After this step, our goal is for the character to look like

<br>
<br>
<img src="steering.gif">
<br>
<br>

<p>However, to get nice movement, we need to tweak the gains: 
ASteerable::kVelKp, ASteerable::kOriKp and ASteerable::kOriKv.

<p>One approach is to tweak these values manually. First, make large changes to find a 
good magnitude for your parameter. Then make smaller changes to fine-tune. Also, change 
parameters systematically, one at a time.

<p>However, our orientation controller is an example of <i>proportional derivative</i> 
control, which has well-understood properties. Specifically, recall that our dynamics 
equation is 

\[
\tau = I(k_{P} (\theta_d - \theta) - k_V \dot{\theta}) 
\]

<p>We first solve for \( \tau \). Then we compute a new angular acceleration with 
\( \ddot{\theta} = \tau/I \). The angular acceleration is then used to turn our 
vehicle. The constants \( k_P, k_V \) for this type of controller can be defined 
in terms of two parameters \( w_n \) and  \( \zeta \) like so

\[
k_P = (w_n)^2 \\
k_V = 2 \zeta w_n
\]

<p>\( w_n \) is called the natural frequency and \( \zeta \) is called the damping ratio.
The rate of convergence follows the function \( e^{-\zeta w_n t}\), so this function will 
be close to zero when \( \zeta w_n t = 4 \). We can use this to choose \( \zeta \) and 
\( w_n \) so that we converge at an approximate time. 

<p>Furthermore, the choice \( \zeta \) will determine if the system is 
underdamped (e.g. oscillates), critically-damped (smoothly goes to \( \theta_d \) ), 
or over-damped. Specifically,

<ul>
		<li><b>Underdamped</b> \( 0 \leq \zeta < 1 \).  In the example below, we have 
		 \( w_n = 8, \zeta = 0.25 \). This choice of values results in \(k_V = 4, k_P = 64 \)
				<br>
				<br>
				<img src="oscillate.gif">
				<br>
				<br>
		<li><b>Critically damped</b> \( \zeta = 1 \).  In the example below, we \( w_n = 8, \zeta = 1 \). 
				This choice of values results in \( k_V = 16, k_P = 64 \)
				<br>
				<br>
				<img src="cdamped.gif">
				<br>
				<br>
		<li><b>Overdamped</b> \( \zeta > 1 \).  In the example below, we \( w_n = 8, \zeta = 2 \) 
				This choice of values results in \( k_V = 32, k_P = 64 \)
				<br>
				<br>
				<img src="overdamped.gif">
				<br>
				<br>
</ul>

= Crowds

<p><b>(5 points)</b> For your orientation control, compute values for the gains kOriKp and kOriKv 
such that the character's turning is critically damped and converges in approximately 0.5 seconds.

<p>A final thought: You may find that if the character sits a while, it accumulates movement. 
You can fix this by either adding a special case to not update when the character is 
close to the goal, or by implementing a more sophisticated behavior which returns 
a desired velocity of zero when within a threshold of the goal.

<p><b>Option 1 (1 points each)</b> Implement additional individual behaviors such as 
flee, avoid obstacles, arrive, depart, and wander. Or feel free to create your own!
<p><b>Option 2 (2 points)</b> Implement a crowd. Extend the basecode to create N 
characters and implement alignment, cohesion, separation, leader

= Unique

Personalize or extend the demos in this assignment. Here are some ideas:

* Make your crowd look heterogeneous by 
** randomizing the colors
** randomizing the sizes
** randomizing the animation time so that motions are no longer synchronized
* Improve the animation of the characters.  Implement a walk controller which blends between walking and standing based on the character's speed. When the speed is zero, the character should idle. When it is walking at the max speed, it should be walking.
* Animate crowds with different types of characters, such as butterflies or stampeding elephants.
* Implement crowds with different-sized characters, such as large ogres mixed with small goblins.

include::handin.adoc[]